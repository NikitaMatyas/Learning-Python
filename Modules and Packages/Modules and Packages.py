# Модули и пакеты

# Когда лучше использовать классы и объекты, а когда - модули

print()

'''
1) Объекты наиболее полезны, когда вам нужно иметь некоторое количество отдельных экземпляров с одинаковым поведением
(методами), но различающихся внутренним состоянием (атрибутами).
2) Классы, в отличие от модулей, поддерживают наследование.
3) Если вам нужен только один объект, модуль подойдет лучше. Независимо от того, сколько обращений к модулю имеется в 
программе, будет загружена только одна копия. Можно использовать модули как синглтоны.
4) Если у вас есть несколько переменных, которые содержат разные значения и могут быть переданы как аргументы в 
несколько функций, лучшего всего определить их как классы. Например, вы можете использовать словарь с ключами size и 
color, чтобы представить цветное изображение в программе и передавать их в качестве аргументов в функции scale() и
transform(). По мере добавления новых ключей и функций может начаться путаница. Более последовательно было бы определить
класс Image с атрибутами size или color и методами scale() и transform(). В этом случае все данные и методы для работы 
с цветными изображениями будут определены в одном месте.
5) Используйте простейшее решение задачи. Словарь, список или кортеж проще, компактнее и быстрее, чем модуль, который,
в свою очередь, проще, чем класс.
'''

# Модули и оператор import
''' Модуль - это всего лишь файл, содержащий код Python. Мы ссылаемся на код других модулей с помощью оператора import. 
Он позволяет получить доступ к коду и переменным этого модуля из вашей программы. 

Простейший вариант использования import выглядит как import модуль, где модуль - имя другого файла Python без 
расширения .py. Симулируем работу метеостанции и выведем на экран отчет о погоде. Основная программа выведет на экран
отчет, а отдельный модуль, содержащий одну функцию, вернет описание погоды, которое будет использовано в отчете.
'''

# Import всегда должен находиться в самом начале файла, в этом файле находится произвольно лишь для демостранции
import report
description = report.get_description()
print("Today's weather:", description)

''' Здесь мы импортировали модуль report целиком, при этом нам нужно было добавить префикс report., чтобы вызвать
функцию get_description(). После этого оператора import все содержимое файла report.py становится доступным основной
программе, нужно лишь ставить перед именем вызываемой функции префикс report.. Путем уточнения содержимого модуля с 
помощью его имени мы избегаем возникновения неприятных конфликтов именования. В каком-то другом модуле также может быть
функция get_description(), и мы не вызовем ее по ошибке.

Во втором случае (в файле report.py) мы находимся внутри функции и знаем, что существует только одна функция с именем
choice, поэтому импортируем функцию choice() непосредственно из модуля random.

Выбирайте стиль, который кажется вам наиболее прозрачным. Имя функции, перед которым стоит имя модуля (random.choice),
использовать безопаснее, однако из-за этого придется набирать немного больше текста.

Можно импортировать код вне функции, если импортируемый код может быть использован более одного раза, и изнутри функции,
если вы знаете, что использование кода будет ограничено. Некоторые люди предпочитают размеать все операторы import
в верхней части файла, чтобы явно обозначить все зависимости их кода. Оба варианта работают.
'''

# Импортирование модуля с другим именем
''' В основной программе мы делали вызов import report. Но что, если у вас есть другой модуль с таким же именем или вы
хотите использовать более короткое или простое имя? В такой ситуации можно выполнить импорт с помощью псевдонима: '''
import report as wr
description = wr.get_description()
print("Today's weather:", description)

# Импортируем только самое необходимое
''' С помощью Python вы можете импортировать одну или несколько частей модуля. Каждая часть может сохранить свое 
оригинальное имя, или же вы можете дать ей alias. Для начала импортируем функцию get_description() из модуля report
с помощью его оригинального имени: '''
from report import get_description
description = get_description()
print("Today's weather:", description)

# Теперь импортируем ее как do_it:
from report import get_description as do_it
description = do_it()
print("Today's weather:", description)

# Пакеты
'''
Модули можно организовать в иерархии файлов, которые называются пакетами. 

Возможно, нам нужны разные типы прогнозов погоды: на следующий день и следующую неделю. В качестве одного из вариантов
мы можем создать папку с именем sources, а внутри неё - два модуля: daily.py и weekly.py. Каждый из них содержит 
функцию forecast. Версия на каждый день возвращает строку, а версия на каждую неделю - список из семи строк.

Рассмотрим основную программу и два модуля. Функция enumerate() разбивает список на части и отправляет каждый элемент
списка в цикл for, добавляя к каждому элементу число в качестве небольшого бонуса.

Основная программа - Modules and Packages.py
Модуль 1 - sources/daily.py
Модуль 2 - sources.weekly.py

В папке sources нам понадобится иметь кое-что еще - файл с именем __init__.py. Он может быть пустым, но Python он нужен
для того, чтобы считать папку, которая его содержит, пакетом.
'''

from sources import daily, weekly
print("Daily forecast:", daily.forecast())
print("Weekly forecast:")
for number, outlook in enumerate(weekly.forecast(), 1):
    print(number, outlook)
